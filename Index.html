<!DOCTYPE html>
<html lang="en">
<head>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>


    <style type="text/css">
        #mynetwork {
            width: 98vw;
            height: 90vh;
            border: 1px solid lightgray;
        }
        .dot {
            height: 25px;
            width: 25px;
            /*margin-left: 15px;*/
            border: 1px black;
            border-radius: 50%;
            display: inline-block;
            /*position: center;*/
        }
        .mal {
            background-color: rgb(233,9,26);

        }
        .vic {
            background-color: rgb(26,19,233);

        }
        .ser {
            background-color: rgb(102,233,64);
        }
        .beg {
            background-color: rgb(159,159,163);
        }
        .label {
            margin-top: 0px;
        }
        .column_1 {
            float: left;
            width: 30%;
        }
        .column_2 {
            float: left;
            width: 7%;
            text-align: center;
        }

        /* Clear floats after the columns */
        .row:after {
            content: "";
            display: table;
            clear: both;
        }
    </style>
</head>
<body>
<div id="wrapper">
    <div id="mynetwork"></div>
    <div id="loadingBar">
        <div class="outerBorder">
            <div id="text">0%</div>
            <div id="border">
                <div id="bar"></div>
            </div>
        </div>
    </div>
</div>
<!--<div id="mynetwork"></div>-->

<div class="row">
    <div class="column_1">
        <input type="text" placeholder="Address" id="node_address_input">
        <input type="button" onclick="clusterByConnection()" value="Cluster node and its connections"/>
    </div>
    <div class="column_2">
        <span class="dot mal"></span>
        <p class="label">Malicious</p>
    </div>
    <div class="column_2">
        <span class="dot vic"></span>
        <p class="label">Victim</p>
    </div>
    <div class="column_2">
        <span class="dot ser"></span>
        <p class="label">Service</p>
    </div>
    <div class="column_2">
        <span class="dot beg"></span>
        <p class="label">Benign</p>
    </div>
</div>

<script type="text/javascript">
    var nodes = new vis.DataSet();
    var edges = new vis.DataSet();
    var gephiImported;

    var nodeContent = document.getElementById("nodeContent");

    var theJson = "";

    $.getJSON("converted_1LYz7EgAF8PU6bSN8GDecnz9Gg814fs81W.json", function() {
        console.log( "success" );
    }).done(function(data){
        theJson = data;
        redrawAll(theJson);
    });

    var container = document.getElementById("mynetwork");


    var data = {
        nodes: nodes,
        edges: edges
    };
    var options = {
        nodes: {
            shape: "dot",
            font: {
                face: "Tahoma"
            },
            color: {
                background: "rgb(233,9,26)",
                border: "rgb(26,19,233)",
                highlight: {
                    background: "rgb(102,233,64)",
                    border: "rgb(159,159,163)"
                },
                hover: {
                    background: "rgb(37,22,233)",
                    border: "rgb(10,9,233)"
                }
            },
        },
        edges: {
            smooth: {
                type: "continuous"
            },
            color: {
                highlight: '#0000ff',
                hover: "rgb(10,9,233)"
            },
            arrows: {
                to: {
                    scaleFactor: 0.5
                }
            },
            selectionWidth: 5
        },
        interaction: {
            dragNodes: false,

            tooltipDelay: 200,
            hideEdgesOnDrag: true,
            hideEdgesOnZoom: true,
            selectConnectedEdges: true
            // hideNodesOnDrag: true
        },
        nodes: {
            shape: "dot",
            size: 16
        },
        // physics: {
        //     enabled: false,
        // },
        // layout: {
        //     hierarchical: {
        //         enabled: true,
        //         direction: 'LR'
        //     }
        // }
        physics: {
            enabled: true,
            timestep: 0.1,
            adaptiveTimestep: true,
            maxVelocity: 1000,
            minVelocity: 30,
            stabilization: {
                enabled: true,
                // iterations: 100,
                updateInterval: 10
            },
            solver: "forceAtlas2Based",
            forceAtlas2Based: {
                gravitationalConstant: -200,
                centralGravity: 0.010,
                damping: 1,
                springLength: 230,
                springConstant: 0.18
            },
        },
        // layout: {
        //     improvedLayout: true,
        //     // randomSeed: 123456789
        // },
        // physics: {
        //     stabilization: { iterations: 10000 },
        //     barnesHut: {
        //         gravitationalConstant: -50000,
        //         springConstant: 0.002,
        //         springLength: 150
        //     },
        //     solver: "barnesHut",
        //     // timestep: 0.1,
        //     adaptiveTimestep: true
        // }
    };

    var network = new vis.Network(container, data, options);

    console.log(data);

    network.on("selectNode", function(params) {
        if (params.nodes.length === 1) {
            if (network.isCluster(params.nodes[0]) === true) {
                network.openCluster(params.nodes[0]);
            }
        }
        console.log(params);
        document.getElementById("node_address_input").value = params.nodes[0];
    });

    network.on("stabilizationProgress", function(params) {
        console.log(params);
        // var maxWidth = 496;
        // var minWidth = 20;
        var widthFactor = params.iterations / params.total;
        // var width = Math.max(minWidth, maxWidth * widthFactor);
        // document.getElementById("bar").style.width = width + "px";
        document.getElementById("text").innerHTML =
            Math.round(widthFactor * 100) + "%";
    });
    network.once("stabilizationIterationsDone", function() {
        document.getElementById("text").innerHTML = "100%";
        // document.getElementById("bar").style.width = "496px";
        // document.getElementById("loadingBar").style.opacity = 0;
        // // console.log(network.edges.hidden);
        // // really clean the dom element
        // setTimeout(function() {
        //     document.getElementById("loadingBar").style.display = "none";
        // }, 500);
    });



    function clusterByConnection() {
        network.setData(data);
        let address = document.getElementById("node_address_input").value;
        console.log(address);
        let color = data.nodes.get(address).color;
        var clusterOptionsByData = {
            clusterNodeProperties: {
                id: 'cluster_' + address,
                title: address,
                label: 'Click to uncluster',
                color: color,
                shape: 'hexagon'
            }
        };
        network.clusterByConnection(address, clusterOptionsByData);
    }


    /**
     * This function fills the DataSets. These DataSets will update the network.
     */
    function redrawAll(gephiJSON) {
        console.log("fissa");
        console.log(gephiJSON);
        console.log(gephiJSON.nodes);
        console.log(gephiJSON.edges);
        console.log(gephiJSON.edges[0]);
        if (gephiJSON.nodes === undefined) {
            gephiJSON = gephiImported;
        } else {
            gephiImported = gephiJSON;
        }

        nodes.clear();
        edges.clear();
        // var parsed_2 = parse_json(gephiJSON);
        // console.log(parsed_2);

        // // Legend
        // var x = -3000;
        // var y = 0;
        // var step = 70;
        //
        // nodes.add({
        //     id: 1000,
        //     x: x,
        //     y: y,
        //     label: "Malicious",
        //     color: "rgb(233,9,26)",
        //     value: 1,
        //     fixed: true,
        //     physics: false
        // });
        // nodes.add({
        //     id: 1001,
        //     x: x,
        //     y: y + step,
        //     label: "Victim",
        //     color: "rgb(26,19,233)",
        //     value: 1,
        //     fixed: true,
        //     physics: false
        // });
        // nodes.add({
        //     id: 1002,
        //     x: x,
        //     y: y + 2 * step,
        //     label: "Service",
        //     color: "rgb(102,233,64)",
        //     value: 1,
        //     fixed: true,
        //     physics: false
        // });
        // nodes.add({
        //     id: 1003,
        //     x: x,
        //     y: y + 3 * step,
        //     label: "Benign",
        //     color: "rgb(159,159,163)",
        //     value: 1,
        //     fixed: true,
        //     physics: false
        // });

        var parsed = vis.parseGephiNetwork(gephiJSON, {
            fixed: false,
            parseColor: false
        });

        // console.log(parsed);
        // console.log(typeof parsed.edges[0]);
        // add the parsed data to the DataSets.
        nodes.add(gephiJSON.nodes);
        edges.add(gephiJSON.edges);



        network.stabilize(100);

        // for (x in nodes) {
        //     console.log(nodes.get())
        // }

        // var clusterOptionsByData = {
        //     clusterNodeProperties: {
        //         id: 'cluster_' + "1Facb8QnikfPUoo8WVFnyai3e1Hcov9y8T",
        //         title: "1Facb8QnikfPUoo8WVFnyai3e1Hcov9y8T",
        //         label: 'Click to uncluster',
        //         shape: 'hexagon'
        //     }
        // };

        // network.clusterByConnection("1Facb8QnikfPUoo8WVFnyai3e1Hcov9y8T", clusterOptionsByData);

        var data = nodes.get(2); // get the data from node 2 as example
        // nodeContent.innerHTML = JSON.stringify(data, undefined, 3); // show the data in the div
        network.fit(); // zoom to fit
    }

    function parse_json(JSON) {
        let parsed_json = [];
        parsed_json.edges = [];
        parsed_json.nodes = [];

        for(i=0;i < JSON.edges.length;i++) {
            parsed_json.edges.push({from:JSON.edges[i].source,to:JSON.edges[i].target,value:JSON.edges[i].width,color:JSON.edges[i].color})
        }
        return parsed_json;
    }

</script>
</body>
</html>